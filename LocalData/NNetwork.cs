//подключение необходимых библиотек
using System;
using System.Windows.Forms;
using System.IO;
using System.Threading;

namespace NNetwork
{
	#region NEURAL NETWORK CLASS DESCRIPTION
	/*
		==================================== НЕЙРОННАЯ СЕТЬ ===================================
								   САРАТОВ СГТУ МОЦ ПИТ ИСТ ИСТ-51 2007 


	   ================ ПРАВИЛА И УСЛОВНЫЕ ОБОЗНАЧЕНИЯ В НАИМЕНОВАНИИ ПЕРЕМЕННЫХ: =============
			   Q в конце - обозначает количество
			   N в конце -обозначает номер
			   имена внутренних переменных - с маленькой буквы
			   имена внешних методов и свойств - с большой буквы


		============================ ОПИСАНИЕ ЧЛЕНОВ КЛАССА ==============================

			void     NNetwork(string)                  - ! конструктор.Загружает конфигурацию сети из файла. Принимает строку - путь к файлу
			void     NNetwork()                        - ! конструктор по умолчанию. Создаёт НС с тремя слоями 100 - 20 - 10
			void     NNetwork(int[])                   - ! конструктор. Принимает массив с числами - количествами нейронов в каждом слое
			void     InitInput (double[])              - функция подачи массива double на вход
			int      LayersQ                           - возвращает количество слоёв в сети
			void     Operate()                         - функция работы сети 
			void     Operate(double[])                 - функция работы сети. Принимает входной массив
			string   MemoryEstimate()                  - функция счётчика памяти. Возвращает строку с примерным расходом памяти на внутренние структуры сети в килобайтах
			double[] GetOutput()                       - функция возвращения массива с выхода
			void     Creating(int[] NQ)                - Функция создания нейронной сети. Используется как основа для конструкторов			
			void     SaveMe(string)                    - функция сохранения конфигурации сети в файл в соответствии со спецификацией. Принимает строку - путь к файлу
			void     InitDefaultParams()				- Функция инициализации параметров сети значениями по умолчанию
			void     Creating(int[])					- Функция создания нейронной сети. Используется как основа для конструкторов
			double   activate (double)					- функция прогона значения  через активационную функцию
			int      HitCount(double[][], double[][])  - функция подсчета количества правильно распознаваемых образов	
			double   GetError(double[])				- Функция расчета суммарной невязки выхода сети и вектора

			double   ErrorEstimate						- функция нахождения ошибки
			(double[][], double[][])					- принимает входные и выходные образы, выдаёт суммарную ошибку для всей эпохи

			double[]  ErrorEstimateArr					- функция нахождения ошибки
			(double[][], double[][])					- принимает входные и выходные образы, выдаёт ошибки для эпохи по всем выходным классам отдельно. 

			void     Study								- функция обучения сети. Принимает тип алгоритма обучения, "рваный" массив массивов входных образов [номер образа][номер признака] 
			(string,double[][],double[][],int)           "рваный" массив массивов выходных образов [номер образа][номер признака] и количество эпох

			double   Threshold                         - чувствительность (порог срабатывания)
			double   Speed 						    - скорость обучения
			double   expA                              - характеристика сигмоиды
			int      Epochs			   		        - продолжительность обучения (кол-во эпох)
			double   Inertion							- мера инерции алгоритма обучения
			int      Fading							- время начала затухания в процентах от продолжительности эпохи
			double   Shift								- значение нейронов-смещений
			double[] ErrorArray						- массив ошибки

			int[]    CloneArray (int[])                - функция клонирования массива	(int)
			double[] CloneArray (double[])             - функция клонирования массива	(double)
			int[]    RandArray (int[])                 - функция рандомизации последовательности. Возвращает рандомизированный массив 



		   =======================ОПИСАНИЕ ЧЛЕНОВ КЛАССА ПОТОКА ОБУЧЕНИЯ=======================

			void Study                                 - функция обучения сети. Принимает "рваный" массив массивов входных образов [номер образа][номер признака] 
			(double[][],double[][],int)                  "рваный" массив массивов выходных образов [номер образа][номер признака] и количество эпох

			void StudyBatch                            - функция обучения сети. Принимает "рваный" массив массивов входных образов [номер образа][номер признака] 
			(double[][],double[][],int)                  "рваный" массив массивов выходных образов [номер образа][номер признака] и количество эпох




	   ====================== СОБЫТИЯ КЛАССА НЕЙРОННОЙ СЕТИ: ===============================

		evtStudyTick              - "тикание" процедуры обучения. Генерируется на каждой десятой эпохе обучения	
		evtStudyFinish            - завершение процедуры обучения.





	   ====================== ФОРМАТ ФАЙЛА КОНФИГУРАЦИИ СЕТИ: ==============================

				1. Версия нейронной сети (int version)
				2. Количество слоёв ( int layersQ);
				3. Скорость обучения(double Speed);
				4. Чувствительность (double Threshold);
				5. Мера инерционности (double Inertion);
				6. Xарактеристика сигмоиды(double expA);
				7. 1D-массив с количествами нейронов в каждом слое (int neuronsQ []);
				8. 2D-матрица текущих состояний нейронов (double state[][]);
				9. 3D-матрица весов нейронов (double w[][,])








   */

	#endregion

	#region NEURAL NETWORK EVENTS
	public delegate void MyEventHandler();

	//событие - "тикание" процедуры обучения	
	public class evtStudyTick
	{
		public event MyEventHandler SomeEvent;
		public void OnSomeEvent()
		{
			if (SomeEvent != null) SomeEvent();

		}
	}
	//событие - заверщение процедуры обучения
	public class evtStudyFinish
	{
		public event MyEventHandler SomeEvent;
		public void OnSomeEvent()
		{
			if (SomeEvent != null) SomeEvent();

		}
	}
	#endregion

	#region NEURAL NETWORK STUDY
	//поток для обучения сети.	
	class thrdStudy
	{
		//локальные переменные потока:
		public NNetwork N;//локальная нейросеть
		public int epoches;
		public double[][] input;
		public double[][] output;
		public double[][] inputTest;
		public double[][] outputTest;
		string alg;
		public Thread thrd;
		//конструктор
		public thrdStudy(string alg, NNetwork N, double[][] input, double[][] output, double[][] inputTest, double[][] outputTest, int epoches)
		{
			//копируем переданные параметры в локальные переменные потока	
			this.N = N;
			this.epoches = epoches;

			this.input = input;
			this.output = output;

			this.inputTest = inputTest;
			this.outputTest = outputTest;

			this.alg = alg;
			//создаём поток	
			thrd = new Thread(new ThreadStart(this.run));
			//запускаем поток на выполнение
			thrd.Start();
		}

		//точка входа
		public void run()
		{
			//вызываем локальную функцию обучения
			if (this.alg == "batch")
			{
				StudyBatch(N, input, output, inputTest, outputTest, epoches);
			}
			else
			{
				Study(N, input, output, inputTest, outputTest, epoches);
			}
		}


		//функция обучения сети. Принимает "рваный" массив массивов входных образов [номер образа][номер признака]
		//и "рваный" массив массивов выходных образов [номер образа][номер признака]
		//аналогично обучающему передаётся тестовое множество
		//и количество эпох
		//пакетный 	
		public void StudyBatch(NNetwork N, double[][] input, double[][] output, double[][] inputTest, double[][] outputTest, int epoches)
		{

			//создаём массив ошибок по эпохам
			N.ErrorArray = new double[epoches];

			//создаём массив ошибок на тестовых множествах по эпохам
			N.ErrorArrayTest = new double[epoches];

			//создаём массив ошибок по образам
			double[][] delt; //дельта
			double[][,] corr, corrP;//коррекции веса

			//размерность delt совпадает с размерностью матрицы состояний
			delt = new double[N.layersQ][];
			for (int y = 0; y < N.layersQ; y++)
				delt[y] = new double[N.neuronsQ[y] + 1];

			//размерность corr и corrP совпадает с размерностью матрицы весов
			corr = new double[N.layersQ][,];
			corrP = new double[N.layersQ][,];

			for (int y = 1; y < N.layersQ; y++)
			{
				corr[y] = new double[N.neuronsQ[y] + 1, N.neuronsQ[y - 1] + 1];
				corrP[y] = new double[N.neuronsQ[y] + 1, N.neuronsQ[y - 1] + 1];
			}

			double LastSpeed;//запомним сюда скорость обучения
			LastSpeed = N.Speed;

			//проверяем на валидность обучающее множество
			if (input.GetLength(0) != output.GetLength(0))
			{
				MessageBox.Show("Не совпадает количество входных и выходных образов", "Ошибка процедуры обучения нейронной сети");
				return;
			}

			//.........................................................................................................			
			Random rnd = new Random();
			for (int i = 1; i < (N.layersQ); i++)       //цикл по слоям (кроме первого)
			{
				int first, last;
				if (i == (N.layersQ - 1))// если  слой последний
				{
					first = 0;
					last = N.neuronsQ[i];
				}
				else
				{
					first = 1;
					last = N.neuronsQ[i] + 1;
				}

				for (int j = 0; j < last; j++)      //цикл по нейронам в каждом слое
				{
					for (int k = 0; k < (N.neuronsQ[i - 1] + 1); k++)       //цикл по синапсам каждого нейрона
					{
						N.w[i][j, k] = rnd.NextDouble() / 2 - 0.25; //инициализируем веса малыми случайными значениями (-0.1 ... 0.1)
					}
				}
			}

			//.........................................................................................................			

			for (int i = 0; i < (N.layersQ); i++)       //цикл по слоям 
			{
				int first, last;
				if (i == (N.layersQ - 1)) //если слой последний
				{
					first = 0;
					last = N.neuronsQ[i];
				}
				else //если слой не последний
				{
					first = 1;
					last = N.neuronsQ[i] + 1;
				}
				for (int j = first; j < last; j++)      //цикл по нейронам в каждом слое (нейрон-смещение остаётся единицей)
				{
					N.state[i][j] = rnd.NextDouble() / 2 - 0.25; //инициализируем значения сети малыми случайными
				}
			}
			//.........................................................................................................			


			//.........................................................................................	
			//обнуление корректирующей матрицы
			for (int ii = 1; ii < (N.layersQ); ii++)        //цикл по слоям (кроме первого)
			{
				int first, last;
				if (ii == (N.layersQ - 1)) //если слой последний
				{
					first = 0;
					last = N.neuronsQ[ii];
				}
				else //если слой не последний
				{
					first = 1;
					last = N.neuronsQ[ii] + 1;
				}

				for (int j = 0; j < (last); j++)        //цикл по нейронам в каждом слое
				{
					for (int k = 0; k < (N.neuronsQ[ii - 1] + 1); k++)      //цикл по синапсам каждого нейрона
					{
						corr[ii][j, k] = 0; //обнуляем корректирующую матрицу
						corrP[ii][j, k] = 0; //обнуляем вторую корректирующую матрицу
					}
				}
			}
			//.........................................................................................	

			for (int ep = 0; ep < epoches; ep++) //начало эпохи обучения
			{
				N.CurEpochs = ep;
				bool flag = false;
				if (N.CurEpochs % 10 == 0)
				{

					N.evt.OnSomeEvent();
				}
				//.........................................................................................................			
				//генерируем случайную последовательность подачи образов	
				int[] rn = new int[input.GetLength(0)];
				for (int e = 0; e < rn.Length; e++)
				{
					rn[e] = e;
				}
				rn = N.RandArray(rn);
				//.........................................................................................................			

				int i;
				for (int img = 0; img < input.GetLength(0); img++) //цикл по всем образам
				{
					i = rn[img];
					N.InitInput(input[i]); //подаём на вход очередной образ
					N.Operate(); // осущ. прогон сети
					double[] arr = new double[output[i].Length];
					arr = N.GetOutput();//записываем выход в массив arr
										//.........................................................................................................				  

					//сравниваем выход сети с учительским выходом
					for (int j = 0; j < output[i].Length; j++)//цикл по вых. образу
					{
						if (Math.Abs(N.activate(output[i][j]) - arr[j]) <= N.Threshold)//если верно
						{
							flag = false;
							continue;//переход к следующему элементу образа					
						}
						else
						{
							flag = true;
							break;//зачем смотреть дальше, если уже неправильно
						}
					}//~цикл по вых. образу j

					//.........................................................................................................						
					double errs = 0;
					for (int r = 0; r < output[i].Length; r++)//цикл по элементам r-того выходного образа
					{
						errs += 0.5 * Math.Pow(N.activate(output[i][r]) - arr[r], 2);
					}//~цикл по элементам w-того выходного образа r
					 //if (errs<=N.Threshold) flag=false; else flag=true;
					 //.........................................................................................................	

					if (flag)//если ошибка велика  и надо корректировать веса
					{
						//.........................................................................................................		
						//сначала подстраиваем веса нейронов последнего слоя

						for (int r = 0; r < N.neuronsQ[N.layersQ - 1]; r++) //цикл по нейронам
						{
							//находим "дельту" (хар-ка уровня нейрона)
							//(дельта)=(производная логистич. ф-ции)*(абс.ошибка)
							delt[N.layersQ - 1][r] = (N.expA * N.state[N.layersQ - 1][r] * (1 - N.state[N.layersQ - 1][r])) * (N.activate(output[i][r]) - arr[r]);

							for (int w = 0; w < (N.neuronsQ[N.layersQ - 2] + 1); w++) //цикл по весам
							{
								//находим коррекцию  для каждого веса
								//(Коррекция)=(Выход передающего нейрона)*(Дельта)*(Скорость)
								corr[N.layersQ - 1][r, w] += N.state[N.layersQ - 2][w] * delt[N.layersQ - 1][r] * N.Speed;//+ N.Inertion*corr[N.layersQ-1][r,w]);
							}//~цикл по весам w

						}//~цикл по нейронам r							
						 //.........................................................................................................		

						//подстраиваем веса нейронов остальных слоёв
						for (int t = N.layersQ - 2; t > 0; t--)//цикл по слоям от предпоследнего ко второму
						{
							for (int r = 1; r < (N.neuronsQ[t] + 1); r++) //цикл по нейронам
							{
								//находим сумму  "дельт" следующего слоя, умноженных на веса
								double sum = 0;
								if (t == N.layersQ - 2)//если слой предпоследний то нейрон-смещение последнего не учитываем
								{
									for (int s = 0; s < (N.neuronsQ[t + 1]); s++)//цикл по нейронам следующего слоя
									{
										sum += (delt[t + 1][s] * N.w[t + 1][s, r]);
									}
								}
								else // если слой не предпоследний
								{
									for (int s = 1; s < (N.neuronsQ[t + 1] + 1); s++)//цикл по нейронам следующего слоя
									{
										sum += (delt[t + 1][s] * N.w[t + 1][s, r]);
									}
								}
								//теперь найдём дельту для этого нейрона
								delt[t][r] = sum * (N.expA * N.state[t][r] * (1 - N.state[t][r]));

								//корректируем питающие синапсы
								for (int a = 0; a < (N.neuronsQ[t - 1] + 1); a++)//цикл по весам
								{
									//находим коррекцию  для каждого веса
									//(Коррекция)=(Выход передающего нейрона)*(дельта)*(скорость)
									corr[t][r, a] += N.state[t - 1][a] * delt[t][r] * N.Speed;// + N.Inertion*corr[t][r,a]);				
								}//~цикл по весам a

							} //~цикл по нейронам r

						}//~цикл по слоям от предпоследнего ко второму t

					}//~корректировка весов
					N.ErrorArray[ep] += N.GetError(output[i]);
					if ((inputTest != null) && (outputTest != null))
					{
						if ((inputTest.Length != 0) && (outputTest.Length != 0))
						{
							N.ErrorArrayTest[ep] = N.ErrorEstimate(inputTest, outputTest);
						}
					}
					//N.ErrorArrayTest[ep]+=N.GetError(outputTest[i]);
				}//~цикл по всем образам i



				//.........................................................................................				
				//каректерроффка весов в конце эпохи
				for (int iii = 1; iii < (N.layersQ); iii++)     //цикл по слоям (кроме первого)
				{
					int first, last;
					if (iii == (N.layersQ - 1)) //если слой последний
					{
						first = 0;
						last = N.neuronsQ[iii];
					}
					else //если слой не последний
					{
						first = 1;
						last = N.neuronsQ[iii] + 1;
					}

					for (int j = first; j < last; j++)      //цикл по нейронам в каждом слое
					{
						for (int k = 0; k < (N.neuronsQ[iii - 1] + 1); k++)     //цикл по синапсам каждого нейрона
						{
							//Вес=(Вес)+(карректероффка)+(предыдущая_карректероффка)*(инерция)
							N.w[iii][j, k] += (corr[iii][j, k] + corrP[iii][j, k] * N.Inertion);//input.GetLength(0);
						}
					}
				}
				//.........................................................................................						


				//.........................................................................................	
				//обнуление корректирующей матрицы и сохранение её для инерции следующей эпохи 
				for (int ii = 1; ii < (N.layersQ); ii++)        //цикл по слоям (кроме первого)
				{
					for (int j = 0; j < (N.neuronsQ[ii] + 1); j++)      //цикл по нейронам в каждом слое
					{
						for (int k = 0; k < (N.neuronsQ[ii - 1] + 1); k++)      //цикл по синапсам каждого нейрона
						{
							corrP[ii][j, k] = corr[ii][j, k];//сохраняем для инерции
							corr[ii][j, k] = 0; //обнуляем корректирующую матрицу
						}
					}
				}
				//.........................................................................................	

				if (N.Fading != 100) //если включено затухание
				{
					//LastSpeed=N.Speed; //запомним скорость чтобы потом восстановить
					if ((ep >= N.Fading * epoches / 100) && (N.Speed >= 0.05)) //понижаем скорость до 0.05
					{
						int F = N.Fading;
						double l1 = epoches * F / 100.0;
						double l2 = epoches * (100 - N.Fading) / 100.0;
						N.Speed = N.Speed * Math.Abs(1 - ((ep - l1) / l2));
					}
				}
				//N.ErrorArray[ep]= N.ErrorEstimate(input,output);//оцениваем ошибку
			}//~конец эпохи обучения
			if (N.Fading != 100) N.Speed = LastSpeed; //если было включено затухание восстанавливаем скорость
													  //N.ErrorArray[ep]= N.ErrorEstimate(input,output);//оцениваем ошибку

			N.evtFinish.OnSomeEvent();  //генерируем событие - завершение обучения
		}//~Study функция




		//===============================================================================================
		//непакетный алгоритм обучения
		public void Study(NNetwork N, double[][] input, double[][] output, double[][] inputTest, double[][] outputTest, int epoches)
		{

			//создаём массив ошибок по эпохам
			N.ErrorArray = new double[epoches];
			//создаём массив ошибок по тестовому множеству по эпохам
			N.ErrorArrayTest = new double[epoches];
			int[] hits = new int[epoches];

			double[][] delt; //дельта

			//размерность delt совпадает с размерностью матрицы состояний
			delt = new double[N.layersQ][];
			for (int y = 0; y < N.layersQ; y++)
				delt[y] = new double[N.neuronsQ[y] + 1];

			double LastSpeed;//запомним сюда скорость обучения
			LastSpeed = N.Speed;

			//проверяем на валидность обучающее множество
			if (input.GetLength(0) != output.GetLength(0))
			{
				MessageBox.Show("Не совпадает количество входных и выходных образов", "Ошибка процедуры обучения нейронной сети");
				return;
			}

			//.........................................................................................................			
			Random rnd = new Random();
			for (int i = 1; i < (N.layersQ); i++)       //цикл по слоям (кроме первого)
			{
				int first, last;
				if (i == N.layersQ - 1) //если слой последний
				{
					first = 0;
					last = N.neuronsQ[i];
				}
				else
				{
					first = 1;
					last = N.neuronsQ[i] + 1;
				}
				for (int j = 0; j < (last); j++)        //цикл по нейронам в каждом слое
				{
					for (int k = 0; k < (N.neuronsQ[i - 1] + 1); k++)       //цикл по синапсам каждого нейрона
					{
						N.w[i][j, k] = rnd.NextDouble() / 2 - 0.25; //инициализируем веса малыми случайными значениями (-0.1 ... 0.1)
					}
				}
			}

			//.........................................................................................................			

			for (int i = 0; i < (N.layersQ); i++)       //цикл по слоям 
			{

				int first, last;
				if (i == N.layersQ - 1) //если слой последний
				{
					first = 0;
					last = N.neuronsQ[i];
				}
				else
				{
					first = 1;
					last = N.neuronsQ[i] + 1;
				}
				for (int j = 1; j < last; j++)      //цикл по нейронам в каждом слое (нейрон-смещение остаётся единицей)
				{
					N.state[i][j] = rnd.NextDouble() / 2 - 0.25; //инициализируем значения сети малыми случайными

				}
			}
			//.........................................................................................................			


			for (int ep = 0; ep < epoches; ep++) //начало эпохи обучения
			{

				N.CurEpochs = ep;
				bool flag = false;
				if (N.CurEpochs % 10 == 0)
				{
					N.evt.OnSomeEvent();
				}
				//.........................................................................................................			
				//генерируем случайную последовательность подачи образов	
				int[] rn = new int[input.GetLength(0)];
				for (int e = 0; e < rn.Length; e++)
				{
					rn[e] = e;
				}
				rn = N.RandArray(rn);
				//.........................................................................................................			

				int i;
				for (int img = 0; img < input.GetLength(0); img++) //цикл по всем образам
				{
					i = rn[img];
					N.InitInput(input[i]); //подаём на вход очередной образ
					N.Operate(); // осущ. прогон сети
					double[] arr = new double[output[i].Length];
					arr = N.GetOutput();//записываем выход в массив arr
										//.........................................................................................................				  

					//сравниваем выход сети с учительским выходом
					for (int j = 0; j < output[i].Length; j++)//цикл по вых. образу
					{
						if (Math.Abs(N.activate(output[i][j]) - arr[j]) <= N.Threshold)//если верно
						{
							flag = false;
							continue;//переход к следующему элементу образа					
						}
						else
						{
							flag = true;
							break;//зачем смотреть дальше, если уже неправильно
						}
					}//~цикл по вых. образу j
					double errs = 0;
					for (int r = 0; r < output[i].Length; r++)//цикл по элементам i-того выходного образа
					{
						errs += 0.5 * Math.Pow(N.activate(output[i][r]) - arr[r], 2);
					} //~цикл по элементам r-того выходного образа 

					//if (errs<=N.Threshold) flag=false; else flag=true;
					//.........................................................................................................	

					if (flag)//если ошибка велика  и надо корректировать веса
					{
						//.........................................................................................................		
						//сначала подстраиваем веса нейронов последнего слоя

						for (int r = 0; r < (N.neuronsQ[N.layersQ - 1]); r++) //цикл по нейронам 
						{
							//находим "дельту" (хар-ка уровня нейрона)
							//(дельта)=(производная логистич. ф-ции)*(абс.ошибка)
							delt[N.layersQ - 1][r] = (N.expA * N.state[N.layersQ - 1][r] * (1 - N.state[N.layersQ - 1][r])) * (N.activate(output[i][r]) - arr[r]);

							for (int w = 0; w < (N.neuronsQ[N.layersQ - 2] + 1); w++) //цикл по весам
							{

								//(Вес)=(Вес)+(Выход передающего нейрона)*(Дельта)*(Скорость)
								N.w[N.layersQ - 1][r, w] += (N.state[N.layersQ - 2][w] * delt[N.layersQ - 1][r] * N.Speed); //+ N.Inertion*corr[N.layersQ-1][r,w]);					

							}//~цикл по весам w

						}//~цикл по нейронам r							
						 //.........................................................................................................		

						//подстраиваем веса нейронов остальных слоёв
						for (int t = N.layersQ - 2; t > 0; t--)//цикл по слоям от предпоследнего ко второму
						{
							for (int r = 1; r < (N.neuronsQ[t] + 1); r++) //цикл по нейронам
							{
								//находим сумму  "дельт" следующего слоя, умноженных на веса
								double sum = 0;
								if (t == N.layersQ - 2)//если слой предпоследний то нейрон-смещение последнего не учитываем
								{
									for (int s = 0; s < (N.neuronsQ[t + 1]); s++)//цикл по нейронам следующего слоя
									{
										sum += (delt[t + 1][s] * N.w[t + 1][s, r]);
									}
								}
								else // если слой не предпоследний
								{
									for (int s = 1; s < (N.neuronsQ[t + 1] + 1); s++)//цикл по нейронам следующего слоя
									{
										sum += (delt[t + 1][s] * N.w[t + 1][s, r]);
									}
								}

								//теперь найдём дельту для этого нейрона
								delt[t][r] = sum * (N.expA * N.state[t][r] * (1 - N.state[t][r]));

								//корректируем питающие синапсы
								for (int a = 0; a < (N.neuronsQ[t - 1] + 1); a++)//цикл по весам
								{
									//корректируем веса
									//(Вес)=(Вес)+(Выход передающего нейрона)*(Дельта)*(Скорость)
									N.w[t][r, a] += (N.state[t - 1][a] * delt[t][r] * N.Speed);// + N.Inertion*corr[t][r,a]);								

								}//~цикл по весам a

							} //~цикл по нейронам r

						}//~цикл по слоям от предпоследнего ко второму t

					}//~корректировка весов
					N.ErrorArray[ep] += N.GetError(output[i]);
				}//~цикл по всем образам i

				//hits[ep]=N.HitCount(input,output);
				if (N.Fading != 100) //если включено затухание
				{
					//LastSpeed=N.Speed; //запомним скорость чтобы потом восстановить
					if ((ep >= N.Fading * epoches / 100) && (N.Speed >= 0.05)) //понижаем скорость до 0.05
					{
						int F = N.Fading;
						double l1 = epoches * F / 100.0;
						double l2 = epoches * (100 - N.Fading) / 100.0;
						N.Speed = N.Speed * Math.Abs(1 - ((ep - l1) / l2));
					}
				}
				//N.ErrorArray[ep]= N.ErrorEstimate(input,output);//оцениваем ошибку
			}//~конец эпохи обучения
			if (N.Fading != 100) N.Speed = LastSpeed; //если было включено затухание восстанавливаем скорость


			N.evtFinish.OnSomeEvent();  //генерируем событие - завершение обучения

		}//~Study функция
	} //~thrdStudy поток
	  //=====================================================================	

	#endregion

	#region NEURAL NETWORK

	public class NNetwork
	{
		#region GENERAL VARIABLES DECLARATION
		//======================================================================  
		// члены класса

		//номер версии нейронной сети 
		public int version = 8;

		//количество слоёв в сети 
		public int layersQ;
		//количество слоёв в сети (свойство)

		//количество нейронов в каждом слое
		//[номер слоя]
		public int[] neuronsQ;

		//матрица весов синаптических связей
		//[номер слоя][номер нейрона , номер синапса]
		public double[][,] w;

		//текущее состояние каждого нейрона 
		//[номер слоя][номер нейрона]
		public double[][] state;

		//продолжительность обучения (кол-во эпох)
		public int Epochs;

		//текущая эпоха
		public int CurEpochs;

		//характеристика сигмоиды
		public double expA;

		//инерционность алгоритма обучения
		public double Inertion;

		//чувствительность (порог срабатывания)
		public double Threshold;

		//скорость обучения
		public double Speed;

		//поток для обучения сети
		public Thread thrd;

		//использовать ли затухание
		//время начала затухания в процентах от продолжительности эпохи
		public int Fading;

		//значение нейронов-смещений
		public double Shift;

		//делегаты для событий
		public evtStudyTick evt = new evtStudyTick();
		public evtStudyFinish evtFinish = new evtStudyFinish();

		//массив ошибки
		public double[] ErrorArray;
		//массив ошибки по тестовому множеству
		public double[] ErrorArrayTest;

		//====================================================================== 
		#endregion
		#region GENERAL FUNCTIONS
		//Функция инициализации параметров сети значениями по умолчанию
		public void InitDefaultParams()
		{
			Speed = 0.5;     //скорость обучения
			Threshold = 0.1;    //чувствительность
			expA = 1;         //характеристика сигмоиды
			Inertion = 0.01;  //мера инерции алгоритма обучения
			Fading = 100;       // затухание
		}
		//===========================================================================================  
		//===========================================================================================  
		//Функция создания нейронной сети. Используется как основа для конструкторов		
		private void Creating(int[] NQ)
		{
			//......................................................................  			
			//если введено неправильное кол-во слоёв
			if ((NQ.Length < 2) || (NQ.Length > 20))
			{
				MessageBox.Show("Введите корректно параметры сети. Количество слоёв должно быть больше двух и меньше 20", "Ошибка построения нейронной сети", MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			//проверка количества нейронов в каждом слое
			for (int i = 0; i < NQ.Length; i++)
			{
				if ((NQ[i] < 1) || (NQ[i] > 500))
				{
					MessageBox.Show("Введите корректно параметры сети. Количество нейронов в слое не может превышать 500 и быть меньше единицы", "Ошибка построения нейронной сети", MessageBoxButtons.OK, MessageBoxIcon.Error);
					return;
				}
			}
			//................................................................................................ 

			//фиксируем во вн. переменные параметры сети

			//................................................................................................ 
			Shift = 1; //задаем смещения нейронов


			//количество нейронов в слоях
			neuronsQ = new int[NQ.Length];
			for (int i = 0; i < NQ.Length; i++)
			{
				neuronsQ[i] = NQ[i];
			}
			//...................................................................... 
			//количество слоёв сети
			layersQ = NQ.Length;
			//...................................................................... 
			//создаём матрицу весовых коэффициентов
			w = new double[layersQ][,];
			Random r = new Random();

			for (int i = 1; i < (layersQ); i++)     //цикл по слоям (кроме первого)
			{
				w[i] = new double[(neuronsQ[i] + 1), (neuronsQ[i - 1] + 1)];
				for (int j = 0; j < (neuronsQ[i] + 1); j++)     //цикл по нейронам в каждом слое
				{

					for (int k = 0; k < (neuronsQ[i - 1] + 1); k++)     //цикл по синапсам каждого нейрона
					{
						w[i][j, k] = r.NextDouble() - 0.5;      //инициализируем веса случайными значениями (-0.5 ... 0.5)
					}
				}
			}
			//...................................................................... 	
			//рассчитываем текущие состояния нейронов
			state = new double[layersQ][];
			state[0] = new double[neuronsQ[0] + 1]; //для первого слоя, т.к. в след. цикле его не захватываем
			state[0][0] = Shift; //задаем нейрон-смещение на первом слое

			for (int i = 1; i < (layersQ); i++)     //цикл по слоям (со второго)
			{
				if (i == (layersQ - 1)) state[i] = new double[neuronsQ[i]]; //если слой последний
				else state[i] = new double[neuronsQ[i] + 1]; //если слой не последний


				state[i][0] = Shift;//задаем нейрон-смещение
			}


			//			for (int j=0;j<(neuronsQ[layersQ-2]+1);j++)	//цикл по синапсам нейрона-смещения в последнем слое
			//			     w[layersQ-1][0,j]=0;



			//инициализируем параметры сети значениями по умолчанию
			this.InitDefaultParams();
		}//~Creating
		 //======================================================================  


		//======================================================================  		
		//конструктор
		// NQ - количество нейронов в каждом слое
		public NNetwork(int[] NQ)

		{
			this.Creating(NQ);

		} //~конструктор
		  //=====================================================================			



		//======================================================================  
		//конструктор по умолчанию
		//создаёт нейронную сеть 100-20-10
		public NNetwork()

		{
			int[] a = new int[3];
			a[0] = 100; a[1] = 20; a[2] = 10;
			this.Creating(a);
		} //~конструктор
		  //=====================================================================		



		//=====================================================================	
		// функция прогона значения  через активационную функцию
		public double activate(double x)
		{
			return (1 / (1 + Math.Exp(-x * expA)));
		}
		//=====================================================================	

		//=====================================================================	
		//функция подачи массива double на вход
		public void InitInput(double[] input)
		{
			//......................................................................	
			if (input.Length != (neuronsQ[0])) //если не совпадает размер входного массива и первого слоя
			{
				MessageBox.Show("Введите корректно параметры сети. Количество входов должно совпадать с размером первого слоя", "Ошибка инициализации входов нейронной сети", MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			//......................................................................
			state[0][0] = Shift;
			//копируем поданный масив на входной слой сети
			for (int i = 1; i < (input.Length + 1); i++)
			{
				state[0][i] = activate(input[i - 1]);
			}
			//......................................................................	
		}//~InitInput
		 //=====================================================================	



		//=====================================================================	
		//функция возвращения массива с выхода
		public double[] GetOutput()
		{
			double[] output = new double[neuronsQ[layersQ - 1]];
			for (int i = 0; i < output.Length; i++)
			{
				output[i] = state[layersQ - 1][i];
			}
			return output;


		} //~GetOutut

		//=====================================================================	
		//функция работы сети (прямое распространение сигналов)
		public void Operate()
		{


			double st;
			state[0][0] = Shift; //нейрон-смещение
			for (int i = 1; i < (layersQ); i++) //цикл по слоям (со второго)
			{
				int LastTmp; //сохраним сюда количество нейронов рассматриваемого слоя
				int FirstTmp; //сохраним сюда индекс первого нейрона рассматриваемого слоя

				if (i == (layersQ - 1)) //если слой последний
				{
					LastTmp = neuronsQ[i];
					FirstTmp = 0;
				}

				else //если слой не последний
				{
					LastTmp = neuronsQ[i] + 1;
					FirstTmp = 1;
				}

				for (int j = FirstTmp; j < LastTmp; j++) //цикл по нейронам каждого слоя (кроме первого (нейрона-смещения) для не последних слоёв)
				{
					st = 0;
					for (int k = 0; k < (neuronsQ[i - 1] + 1); k++) //цикл по синапсам
					{
						st += (state[i - 1][k] * w[i][j, k]);   //считаем взвешенную сумму
					}

					//пропускаем взвешенную сумму через активационную функцию (сигмоид)
					state[i][j] = activate(st);
				}
				//state[i][0]=Shift;  //нейрон-смещение остаётся единицей
			}



		}//~Operate

		//=====================================================================	



		//=====================================================================	
		//функция работы сети.(перегруженная) Принимает входной массив 
		public void Operate(double[] input)
		{
			this.InitInput(input);   //инициализация входов
			this.Operate();          //работа сети
		}//~Operate

		//=====================================================================	




		//=====================================================================	
		//функция обучения сети. 

		//Принимает "рваный" массив массивов входных образов [номер образа][номер признака]
		// "рваный" массив массивов выходных образов [номер образа][номер признака]
		// и количество эпох

		public void Study(string alg, double[][] input, double[][] output, double[][] inputTest, double[][] outputTest, int epoches)
		{
			//создаём поток, который внутри себя обучает сеть
			thrdStudy th = new thrdStudy(alg, this, input, output, inputTest, outputTest, epoches);
		}
		#endregion
		#region ERROR ESTIMATING FUNCTIONS
		//=====================================================================	
		public int HitCount(double[][] input, double[][] output)
		{
			int Count = 0;
			int number;
			int number2;
			double[] exx;
			for (int w = 0; w < input.GetLength(0); w++)//цикл по образам
			{
				this.InitInput(input[w]);//подаём w-тый массив на вход
				this.Operate();          //прогон сети
				exx = new double[output[w].Length];//создаём массив для выходного образа
				exx = this.GetOutput();//записываем в него выход	
									   //.................................................................................................. 			
				double minDiff = 10000;
				number = -1;

				for (int r = 0; r < output[w].Length; r++)//цикл по элементам w-того выходного образа
				{
					if (Math.Abs(exx[r] - activate(10)) <= minDiff) //если нашли меньше, чем текущий минимум
					{
						minDiff = (Math.Abs(exx[r] - activate(10)));
						number = r; //распознанный вых. признак
					}
				} //~цикл по элементам w-того выходного образа
				  //..................................................................................................			
				  //ищем номер максимального элемента в учительском выходе		
				double max = -10000; number2 = -1;
				for (int r = 0; r < output[w].Length; r++)//цикл по элементам w-того выходного образа
				{
					if (output[w][r] >= max)
					{
						max = output[w][r];
						number2 = r; //заданный  вых. признак

					}
				}
				if (number == number2) Count++;
			}

			return Count;
		}
		//=====================================================================
		//функция нахождения ошибки
		//принимает входные и выходные образы, выдаёт суммарную ошибку для всей эпохи. Индекс-номер образа
		public double ErrorEstimate(double[][] input, double[][] output)
		{
			// double[] Error= new double[input.GetLength(0)];//создаём массив ошибки. Индекс-номер образа
			double Err;
			Err = 0;
			double[] exx;
			double errsum; errsum = 0;
			for (int w = 0; w < input.GetLength(0); w++)//цикл по образам
			{
				this.InitInput(input[w]);//подаём w-тый массив на вход
				this.Operate();//прогон сети
				exx = new double[output[w].Length];//создаём массив для выходного образа
				exx = this.GetOutput();//записываем в него выход	


				errsum = 0;
				for (int r = 0; r < output[w].Length; r++)//цикл по элементам w-того выходного образа
				{
					errsum += Math.Pow((exx[r] - activate(output[w][r])), 2);
				}//~цикл по элементам w-того выходного образа r
				Err += 0.5 * errsum;
			}//~цикл по образам w

			return Err;

		}//~ErrorEstimate


		//=================================================================================== 
		//Функция расчета суммарной невязки выхода сети и вектора 		
		public double GetError(double[] answ)
		{
			double errsum = 0;
			for (int r = 0; r < answ.Length; r++)
			{
				errsum += Math.Pow((state[layersQ - 1][r] - activate(answ[r])), 2);
			}
			return errsum * 0.5;
		}


		//=================================================================================== 
		//функция нахождения ошибки (перегруженная)
		//принимает входные и выходные образы, выдаёт ошибки для эпохи по всем выходным классам отдельно. 
		public double[] ErrorEstimateArr(double[][] input, double[][] output)
		{
			double[] Error = new double[output[0].Length];//создаём массив ошибки. Индекс-номер класса
			double Err = new double();
			Err = 0;

			double[] exx;
			double errsum; errsum = 0;
			for (int w = 0; w < input.GetLength(0); w++)//цикл по образам
			{
				this.InitInput(input[w]);//подаём w-тый массив на вход
				this.Operate();//прогон сети
				exx = new double[output[w].Length];//создаём массив для выходного образа
				exx = this.GetOutput();//записываем в него выход	


				errsum = 0;
				for (int r = 0; r < output[w].Length; r++)//цикл по элементам w-того выходного образа
				{
					errsum += Math.Pow((exx[r] - activate(output[w][r])), 2);
				}//~цикл по элементам w-того выходного образа r

				Error[w] = errsum * 0.5;

			}//~цикл по образам w

			return Error;

		}//~ErrorEstimate


		//=================================================================================== 
		#endregion
		#region INPUT/OUTPUT FUNCTIONS
		//=====================================================================	
		// функция сохранения конфигурации сети в файл в соответствии со спецификацией
		public void SaveMe(string path)
		{

			BinaryWriter sw;
			try
			{
				sw = new BinaryWriter(new FileStream(path, FileMode.Create));
			}
			catch (IOException exc)
			{
				MessageBox.Show("Произошла ошибка ввода-вывода \n" + exc.Message, "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			//......................................................................	

			try
			{
				//записываем версию сети
				sw.Write(this.version);

				//записываем кол-во слоёв
				sw.Write(this.layersQ);

				//записываем скорость обучения
				sw.Write(this.Speed);

				//записываем чувствительность
				sw.Write(this.Threshold);

				//записываем меру инерционности
				sw.Write(this.Inertion);

				//записываем характеристику сигмоиды
				sw.Write(this.expA);


				//записываем массив, содерж. кол-ва нейронов в слоях
				for (int i = 0; i < this.layersQ; i++)
					sw.Write(neuronsQ[i]);

				//записываем текущие состояния нейронов
				for (int i = 0; i < this.layersQ; i++)//цикл по слоям
					if (i == (layersQ - 1)) //если последний слой
					{
						for (int j = 0; j < this.neuronsQ[i]; j++)//цикл по нейронам 
							sw.Write(this.state[i][j]);
					}
					else //если слой не последний
					{
						for (int j = 0; j < this.neuronsQ[i] + 1; j++)//цикл по нейронам
							sw.Write(this.state[i][j]);
					}


				//записываем веса
				for (int i = 1; i < this.layersQ; i++)//цикл по слоям
					if (i == (layersQ - 1)) //если последний слой
					{
						for (int j = 0; j < this.neuronsQ[i]; j++)//цикл по нейронам
							for (int k = 0; k < this.neuronsQ[i - 1] + 1; k++) //цикл по синапсам
								sw.Write(this.w[i][j, k]);
					}
					else //если слой не последний
					{
						for (int j = 0; j < this.neuronsQ[i] + 1; j++)//цикл по нейронам
							for (int k = 0; k < this.neuronsQ[i - 1] + 1; k++) //цикл по синапсам
								sw.Write(this.w[i][j, k]);
					}

				sw.Close();
			}
			catch (IOException exc)
			{
				MessageBox.Show("Произошла ошибка ввода-вывода.\n Невозможно сохранить параметры \n" + exc.Message, "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			//......................................................................			


		}//~Save

		//=====================================================================	




		//=====================================================================	
		// функция загрузки конфигурации сети из файла в соответствии со спецификацией (конструктор)
		public NNetwork(string path)
		{

			BinaryReader sr;
			try
			{
				sr = new BinaryReader(new FileStream(path, FileMode.Open));
			}
			catch (IOException exc)
			{
				MessageBox.Show("Произошла ошибка ввода-вывода \n" + exc.Message, "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			//......................................................................	

			try
			{

				//читаем версию
				int ver = sr.ReadInt32();
				if (ver != this.version)
				{
					MessageBox.Show("Несовместимая версия нейронной сети \n", "Ошибка открытия файла", MessageBoxButtons.OK, MessageBoxIcon.Error);
					return;
				}

				//читаем кол-во слоёв
				this.layersQ = sr.ReadInt32();

				//читаем коэффициент скорости обучения
				this.Speed = sr.ReadDouble();

				//читаем чувствительность нейронов
				this.Threshold = sr.ReadDouble();

				//читаем меру инерции алгоритма обучения
				this.Inertion = sr.ReadDouble();

				//читаем характеристику сигмоиды
				this.expA = sr.ReadDouble();


				//читаем массив, содерж. кол-ва нейронов в слоях
				neuronsQ = new int[layersQ];
				for (int i = 0; i < this.layersQ; i++)
					neuronsQ[i] = sr.ReadInt32();

				//читаем текущие состояния нейронов
				state = new double[layersQ][];

				for (int i = 0; i < this.layersQ; i++)//цикл по слоям
				{
					if (i == (layersQ - 1)) //если последний слой
					{
						state[i] = new double[neuronsQ[i]];
						for (int j = 0; j < this.neuronsQ[i]; j++)//цикл по нейронам
							this.state[i][j] = sr.ReadDouble();
					}
					else //если слой не последний
					{
						state[i] = new double[neuronsQ[i] + 1];
						for (int j = 0; j < this.neuronsQ[i] + 1; j++)//цикл по нейронам
							this.state[i][j] = sr.ReadDouble();
					}


				}


				//читаем веса
				w = new double[layersQ][,];
				for (int i = 1; i < this.layersQ; i++)//цикл по слоям
				{
					if (i == (layersQ - 1)) //если последний слой
					{
						w[i] = new double[neuronsQ[i], neuronsQ[i - 1] + 1];
						for (int j = 0; j < this.neuronsQ[i]; j++)//цикл по нейронам
							for (int k = 0; k < this.neuronsQ[i - 1] + 1; k++) //цикл по синапсам
								this.w[i][j, k] = sr.ReadDouble();
					}

					else // если слой не последний
					{
						w[i] = new double[neuronsQ[i] + 1, neuronsQ[i - 1] + 1];
						for (int j = 0; j < this.neuronsQ[i] + 1; j++)//цикл по нейронам
							for (int k = 0; k < this.neuronsQ[i - 1] + 1; k++) //цикл по синапсам
								this.w[i][j, k] = sr.ReadDouble();
					}

				}


				sr.Close();
			}
			catch (IOException exc)
			{
				MessageBox.Show("Произошла ошибка ввода-вывода.\n Невозможно загрузить параметры сети \n" + exc.Message, "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			//......................................................................			


		}//~конструктор
		 //===================================================================================    
		#endregion
		#region AUXILIARY FUNCTIONS

		//функция визуализации сети
		public void PaintMe()
		{
			//  Graphics g = new Gra
		}
		//===================================================================================    

		//=====================================================================	
		//функция клонирования массива	(int)
		public int[] CloneArray(int[] a)
		{
			int[] b = new int[a.Length];
			for (int t = 0; t < a.Length; t++)
			{
				b[t] = a[t];
			}
			return b;
		}

		//=====================================================================	



		//=====================================================================	
		//функция клонирования массива	(double)
		public double[] CloneArray(double[] a)
		{
			double[] b = new double[a.Length];
			for (int t = 0; t < a.Length; t++)
			{
				b[t] = a[t];
			}
			return b;
		}

		//=====================================================================	



		//=====================================================================	
		//функция рандомизации последовательности 
		//возвращает рандомизированный массив из X елементафф
		public int[] RandArray(int[] x)
		{
			Random rnd = new Random();
			int tmp;
			tmp = rnd.Next(x.Length - 1);
			//flag=true;

			int[] arr = new int[x.Length];
			int[] arr2 = new int[x.Length];
			int[] a = new int[x.Length];
			int[] b = new int[x.Length];

			for (int i = 0; i < x.Length; i++)
			{
				a[i] = i;
			}
			b = this.CloneArray(a);

			for (int i = (x.Length - 1); i > 0; i--)//обратный цикл 
			{

				tmp = rnd.Next(a.Length - 1);
				arr[i] = a[tmp];

				b = this.CloneArray(a); //b - копия а
				a = new int[i];
				//копируем элементы (кроме выбранного tmp) в урезаннный массив 
				for (int j = 0; j < tmp; j++)
				{
					a[j] = b[j];
				}
				//копируем элементы (кроме выбранного tmp) в урезаннный массив 
				for (int j = tmp; j < a.Length; j++)
				{
					a[j] = b[j + 1];
				}
			}
			arr[0] = a[0];//для первого, т.к. в цикле его не захватываем

			int y = 0;
			for (int k = 0; k < x.Length; k++)//ставим соответствие чисел индексам
			{
				arr2[y] = x[arr[k]]; y++;
			}

			return arr2;
		}//~RandArrray


		//=====================================================================
		// функция счётчика памяти
		//возвращает примерный расход памяти на внутренние структуры сети в килобайтах
		public string MemoryEstimate()
		{
			int w, s, n; w = s = n = 0;
			//...................................................................... 
			//считаем затраты на матрицу весов	
			for (int i = 1; i < (layersQ); i++) //цикл по слоям (кроме первого)
			{
				w = w + neuronsQ[i] * neuronsQ[i - 1]; //считаем количество синапсов
			}
			w = w * 8;// double=4б
					  //......................................................................
					  //считаем затраты на матрицу состояний
			for (int i = 0; i < (layersQ); i++) //цикл по слоям
				for (int j = 0; j < (neuronsQ[i]); j++) //цикл по нейронам каждого слоя
				{
					s = s + 1;
				}
			s = s * 8;  // double=4б
						//......................................................................
						//считаем затраты на массив количества нейронов
			n = (layersQ * 4);

			return "Внутренние структуры нейронной сети занимают примерно " + (Math.Round(((double)(n + s + w) / 1024), 1)).ToString() + " Кбайт";
		} //~MemoryEstimate
		  //=====================================================================
		#endregion
	}  //~класс NNework

}  //~пространство имён NNework
#endregion